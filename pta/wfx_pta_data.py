#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set sw=4 expandtab:
#
# Created: 2019-08-06
# Main authors:
#     - Marc Dorval <marc.dorval@silabs.com>
#
# Copyright (c) 2019, Silicon Laboratories
# See license terms contained in COPYING file
#

# Generate PTA bytes from input parameters
#

from __future__ import print_function

# If you modify this file, please don't forget to increment version number.
__version__ = "0.2.1"

import sys
import argparse


class PtaSettings(object):
    def __init__(self):
        super().__init__()
        self.pta_cmd = None


class WfxPtaData(object):

    settings_parameters = [
        #  Parameter, type, bytes, choices, default, help
        ('config', str, 1, ['3w_ble', '3w_not_combined_zigbee', '3w_combined_zigbee'], None, """
              Preset configurations for common use cases
                  (presets required non-default 'settings' options,
                  these can then be overwritten using options listed below)"""),
        ('pta_mode', str, 1, {'3w': 0, '1w_coex_master': 1, '2w': 2, '3w': 3, '4w': 4}, '3w', """
              PTA mode selection"""),
        ('request_signal_active_level', str, 1, {'low': 0, 'high':  1}, 'high', """
              Active level on REQUEST signal, provided by Coex to request the RF"""),
        ('priority_signal_active_level', str, 1, {'low': 0, 'high':  1}, 'high', """
              Active level on PRIORITY signal, provided by Coex to set the priority of the request"""),
        ('freq_signal_active_level', str, 1, {'low': 0, 'high':  1}, 'high', """
              Active level on FREQ signal, provided by Coex in 4-wire mode 
              when Coex and Wlan share the same band"""),
        ('grant_signal_active_level', str, 1, {'low': 0, 'high':  1}, 'low', """
              Active level on grant signal, generated by PTA 
              to grant the RF to Coex"""),
        ('coex_type', str, 1, {'generic': 0, 'ble': 1}, 'ble', """
              Coex type"""),
        ('default_grant_state', str, 1, {'no_grant': 0, 'grant': 1}, 'grant', """
              state of the grant signal before arbitration at grant_valid_time"""),
        ('simultaneous_rx_accesses', str, 1, {'false': 0, 'true': 1}, 'false', """
          (uint8),  Boolean to allow both Coex and Wlan to receive concurrently, 
              also named combined mode"""),
        ('priority_sampling_time', int, 1, None, 10, """
          (uint8),  Time in microseconds from the Coex request to the sampling of the
          priority on PRIORITY signal (1 to 31),"""),
        ('tx_rx_sampling_time', int, 1, None, 50, """
          (uint8),  Time in microseconds from the Coex request to the 
              sampling of the directionality on PRIORITY signal (priority_sampling_time to 63)"""),
        ('freq_sampling_time', int, 1, None, 40, """
          (uint8),  Time in microseconds from the Coex request to the 
              sampling of the freq-match information on FREQ signal (1 to 127)"""),
        ('grant_valid_time', int, 1, None, 72, """
          (uint8),  Time in microseconds from Coex request to the 
              grant signal assertion (max(tx_rx_sampling_time, freq_sampling_time), to 0xFF),"""),
        ('fem_control_time', int, 1, None, 140, """
          (uint8),  Time in microseconds from Coex request to the 
              control of FEM (grant_valid_time to 0xFF),"""),
        ('first_slot_time', int, 1, None, 150, """
          (uint8),  Time in microseconds from the Coex request to the 
              beginning of reception or transmission (grant_valid_time to 0xFF),"""),
        ('periodic_tx_rx_sampling_time', int, 2, None, 1, """
          (uint16), Period in microseconds from first_slot_time of following samplings of the 
              directionality on PRIORITY signal (1 to 1023),"""),
        ('coex_quota', int, 2, None, 7500, """
          (uint16), Duration in microseconds for which RF is granted to Coex 
              before it is moved to Wlan"""),
        ('wlan_quota', int, 2, None, 7500, """
          (uint16), Duration in microseconds for which RF is granted to Wlan 
              before it is moved to Coex""")
    ]

    priority_parameters = [
        #  Parameter, type, bytes,  choices, default, help
        ('priority_mode', str, 4, {'coex_maximized': 0x0562, 'coex_high':0x0462, 'balanced':0x1461, 'wlan_high':0x1851, 'wlan_maximized': 0x1A51}, 'balanced', """
            coex_maximized = 0x0562 : Maximizes priority to COEX, WLAN connection is not ensured.  
            coex_high      = 0x0462 : High priority to COEX, targets low-latency to COEX. 
            balanced       = 0x1461 : Balanced PTA arbitration, WLAN acknowledge receptions are protected. 
            wlan_high      = 0x1851 : High priority to WLAN, protects WLAN transmissions. 
            wlan_maximized = 0x1A51 : Maximizes priority to WLAN""")
    ]

    state_parameters = [
        #  Parameter, type, bytes,  choices, default, help
        ('state', str, 4, {'off': 0, 'on': 1}, 'off', """
            PTA state on/off""")
    ]

    def __init__(self, mode=None, **kwargs):
        self.g_settings = PtaSettings
        self.g_settings.pta_cmd = None
        self.sysargs = sys.argv[1:]
        self.mode = mode if mode else 'quiet'

    def set_args(self, args=None):
        if args is not None:
            self.sysargs = args.split(' ')
        else:
            self.sysargs = []

    def print_if_verbose(self, txt, end=None):
        if self.mode == 'verbose':
            print(txt, end=end)

    def data(self):
        self.print_if_verbose(self.sysargs)
        self.g_settings = PtaSettings
        self.g_settings.pta_cmd = None
        user_options = self.parse_cmdline(self, self.sysargs)
        # self.print_if_verbose(user_options)
        self.apply_options(self, user_options)
        return self.pta_bytes()

    @staticmethod
    def parse_cmdline(self, args):
        parser = argparse.ArgumentParser(
                                        formatter_class=argparse.RawDescriptionHelpFormatter,
                                        description="""
        Prepare and send PTA parameters depending on the selected pta_cmd
        """,
                                        epilog="""
        Examples:

        Python3 interpreter:
        python3
         >>> from wfx_pta import *
        selecting the connection mode to match your DUT:
         >>> dut = WfxPtaTarget('Pi203', host='pi203', user='pi', port=22, password='default_password')
         >>> dut = WfxPtaTarget('Serial', port='COM8')
         >>> dut = WfxPtaTarget('Local')
         selecting settings, priority and activating PTA:
         >>> dut.settings('--config 3w_ble --first_slot_time 123')
         >>> dut.priority('--priority_mode balanced')
         >>> dut.state('--state on')
         activating PTA traces (tracks PTA data values):
         >>> dut.trace = True
         activating communication link traces (tracks bytes write/read):
         >>> dut.link.trace = True
         
        Command line using 'wfx_pta.py': directly sending PTA bytes to a 'Local' DUT: 
         (bytes silently sent to DUT)
           python wfx_pta.py settings --config 3w_ble
           python wfx_pta.py priority --priority_mode balanced
           python wfx_pta.py state --state on
         (verbose mode)
           python wfx_pta.py settings --config 3w_ble verbose
            Local: configuring a Direct connection
            ['settings', '--config', '3w_ble']
            configuring for 3w_ble
            pta_mode                        1w_wlan_master =>       3w
            coex_type                        generic =>      ble
            tx_rx_sampling_time                   50 =>        0
            freq_sampling_time                    40 =>        0
            first_slot_time                      150 =>        0
            periodic_tx_rx_sampling_time           1 =>        0
            pta_mode                          3w         \\x03
            request_signal_active_level       high       \\x01
            priority_signal_active_level      high       \\x01
            freq_signal_active_level          high       \\x01
            grant_signal_active_level         low        \\x00
            coex_type                         ble        \\x01
            default_grant_state               grant      \\x01
            simultaneous_rx_accesses          false      \\x00
            priority_sampling_time            10         \\x0a
            tx_rx_sampling_time               0          \\x00
            freq_sampling_time                0          \\x00
            grant_valid_time                  72         \\x48
            fem_control_time                  140        \\x8c
            first_slot_time                   0          \\x00
            periodic_tx_rx_sampling_time      0          \\x00\\x00
            coex_quota                        7500       \\x4c\\x1d
            wlan_quota                        7500       \\x4c\\x1d
            Local    D>>|  wfx_exec wfx_hif_send_msg "\\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x01\\x00\\x01\\x01\\x00\\x0a\\x00\\x00\\x48\\x8c\\x00\\x00\\x00\\x4c\\x1d\\x4c\\x1d"
            Local    D<<|  0

        Command line using 'wfx_pta_data.py': retrieving the PTA bytes (no byte sent to HW):
          python wfx_pta_data.py settings --config 3w_ble
            \\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x01\\x00\\x01\\x01\\x00\\x0a\\x00\\x00\\x48\\x8c\\x00\\x00\\x00\\x4c\\x1d\\x4c\\x1d
          python wfx_pta_data.py settings --config 3w_ble --grant_valid_time 40 --priority_sampling_time 8
            \\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x01\\x00\\x01\\x01\\x00\\x08\\x00\\x00\\x28\\x8c\\x00\\x00\\x00\\x4c\\x1d\\x4c\\x1d
          python wfx_pta_data.py priority --priority_mode balanced
            \\x08\\x00\\x2c\\x00\\x61\\x14\\x00\\x00
          python wfx_pta_data.py state --state on
            \\x08\\x00\\x2d\\x00\\x01\\x00\\x00\\x00
          python wfx_pta_data.py state --state off
            \\x08\\x00\\x2d\\x00\\x00\\x00\\x00\\x00
        
        """)
        parser.add_argument("pta_cmd", choices=['settings', 'priority', 'state'],
                            help="pta_cmd <settings/priority/state>")
        parser.add_argument('--version', action='version',
                            version='%(prog)s {version}'.format(version=__version__))

        parser_settings = parser.add_argument_group('settings options')
        for item in self.settings_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            if _default is None:
                parser_settings.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)
            else:
                parser_settings.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help +
                                             ' (default ' + str(_default) + ')')

        parser_priority = parser.add_argument_group('priority options')
        for item in self.priority_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            parser_priority.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)

        parser_state = parser.add_argument_group('state options')
        for item in self.state_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            parser_state.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)

        return parser.parse_args(args)

    @staticmethod
    def settings_by_config(self, config):

        if config == '3w_ble':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '3w'
            self.g_settings.request_signal_active_level = 'high'
            self.g_settings.priority_signal_active_level = 'high'
            self.g_settings.freq_signal_active_level = 'high'
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.coex_type = 'ble'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.simultaneous_rx_accesses = 'false'
            self.g_settings.priority_sampling_time = 10
            self.g_settings.tx_rx_sampling_time = 0
            self.g_settings.freq_sampling_time = 0
            self.g_settings.grant_valid_time = 72
            self.g_settings.fem_control_time = 140
            self.g_settings.first_slot_time = 0
            self.g_settings.periodic_tx_rx_sampling_time = 0
            self.g_settings.coex_quota = 7500
            self.g_settings.wlan_quota = 7500

        if config == '3w_not_combined_zigbee':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '3w'
            self.g_settings.request_signal_active_level = 'high'
            self.g_settings.priority_signal_active_level = 'high'
            self.g_settings.freq_signal_active_level = 'high'
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.coex_type = 'generic'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.simultaneous_rx_accesses = 'false'
            self.g_settings.priority_sampling_time = 10
            self.g_settings.tx_rx_sampling_time = 0
            self.g_settings.freq_sampling_time = 0
            self.g_settings.grant_valid_time = 20
            self.g_settings.fem_control_time = 20
            self.g_settings.first_slot_time = 0
            self.g_settings.periodic_tx_rx_sampling_time = 0
            self.g_settings.coex_quota = 7500
            self.g_settings.wlan_quota = 7500

        if config == '3w_combined_zigbee':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '3w'
            self.g_settings.request_signal_active_level = 'high'
            self.g_settings.priority_signal_active_level = 'high'
            self.g_settings.freq_signal_active_level = 'high'
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.coex_type = 'generic'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.simultaneous_rx_accesses = 'true'
            self.g_settings.priority_sampling_time = 10
            self.g_settings.tx_rx_sampling_time = 30
            self.g_settings.freq_sampling_time = 0
            self.g_settings.grant_valid_time = 40
            self.g_settings.fem_control_time = 40
            self.g_settings.first_slot_time = 40
            self.g_settings.periodic_tx_rx_sampling_time = 1
            self.g_settings.coex_quota = 7500
            self.g_settings.wlan_quota = 7500

    @staticmethod
    def apply_options(self, options):
        # filling defaults and self.g_settings with default values
        defaults = self.parse_cmdline(self, args=['settings'])
        self.g_settings = self.parse_cmdline(self, args=['settings'])
        if options.config is not None:
            self.settings_by_config(self, options.config)
            # Tracing modified values after applying config
            for k in self.g_settings.__dict__.keys():
                if '__' not in k:
                    config_value = self.g_settings.__dict__[k]
                    default_value = defaults.__dict__[k]
                    if config_value != default_value:
                        self.print_if_verbose("%-30s %8s => %8s" % (k, default_value, config_value))
        self.g_settings.pta_cmd = options.pta_cmd
        if options.pta_cmd == 'priority':
            self.g_settings.priority_mode = options.priority_mode
        if options.pta_cmd == 'state':
            self.g_settings.state = options.state
        # Applying user 'settings' options on top of current settings
        for k in options.__dict__.keys():
            if '__' not in k and k != 'config':
                user_value = options.__dict__[k]
                default_value = defaults.__dict__[k]
                config_value = self.g_settings.__dict__[k]
                if user_value != default_value:
                    if config_value != user_value:
                        self.print_if_verbose("%-30s %8s -> %8s" % (k, config_value, user_value))
                        self.g_settings.__dict__[k] = user_value

    def pta_bytes(self):
        header = []
        payload = list()
        nb_bytes = 4
        cmd_id = 0
        # self.print_if_verbose("PTA command: %s" % self.g_settings.pta_cmd)
        if self.g_settings.pta_cmd == 'settings':
            cmd_id = 0x002b
            for item in self.settings_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                if _name != 'config':
                    item_value = self.g_settings.__dict__[_name]
                    if str(item_value).isnumeric():
                        int_value = int(item_value)
                    else:
                        int_value = int(_choices[item_value])
                    if _bytes == 1:
                        payload.append(str.format(r"\x%02x" % (int_value & 0x00FF)))
                    if _bytes == 2:
                        payload.append(str.format(r"\x%02x" % (int_value & 0x00FF)))
                        payload.append(str.format(r"\x%02x" % int((int_value & 0xFF00) >> 8)))
                    self.print_if_verbose(str.format("%-30s %-10s " % (_name, item_value)), end='')
                    self.print_if_verbose(''.join(payload[(nb_bytes-4):]))
                    nb_bytes += _bytes
        if self.g_settings.pta_cmd == 'priority':
            cmd_id = 0x002c
            for item in self.priority_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                item_value = self.g_settings.__dict__[_name]
                if str(item_value).isnumeric():
                    int_value = int(item_value)
                else:
                    int_value = int(_choices[item_value])
                payload.append(str.format(r"\x%02x" % ((int_value & 0x000000FF) >> 0)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x0000FF00) >> 8)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x00FF0000) >> 16)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0xFF000000) >> 24)))
                self.print_if_verbose(str.format("%-30s %-10s " % (_name, item_value)), end='')
                self.print_if_verbose(''.join(payload[(nb_bytes - 4):]))
                nb_bytes += _bytes
        if self.g_settings.pta_cmd == 'state':
            cmd_id = 0x002d
            for item in self.state_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                item_value = self.g_settings.__dict__[_name]
                if str(item_value).isnumeric():
                    int_value = int(item_value)
                else:
                    int_value = int(_choices[item_value])
                payload.append(str.format(r"\x%02x" % ((int_value & 0x000000FF) >> 0)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x0000FF00) >> 8)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x00FF0000) >> 16)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0xFF000000) >> 24)))
                self.print_if_verbose(str.format("%-30s %-10s " % (_name, item_value)), end='')
                self.print_if_verbose(''.join(payload[(nb_bytes-4):]))
                nb_bytes += _bytes
        header.append(str.format(r"\x%02x" % int(nb_bytes & 0x00FF)))
        header.append(str.format(r"\x%02x" % int(nb_bytes & 0xFF00)))
        header.append(str.format(r"\x%02x" % int(cmd_id & 0x00FF)))
        header.append(str.format(r"\x%02x" % int(cmd_id & 0xFF00)))
        data_bytes = r''.join(header + payload)
        return data_bytes


def command_line_main():
    if 'verbose' in sys.argv:
        mode = 'verbose'
        sys.argv.remove('verbose')
    else:
        mode = 'quiet'
    sys.exit(WfxPtaData(mode).data())


def command_line_test():
    pta = WfxPtaData()
    pta.mode = 'verbose'
    pta.set_args('settings --config 3w_ble --request_signal_active_level low --first_slot_time 123'); print(pta.data())
    pta.mode = 'quiet'
    pta.set_args('settings --pta_mode 1w_coex_master'); print(pta.data())
    pta.set_args('settings --pta_mode 2w'); print(pta.data())
    pta.set_args('settings --pta_mode 3w'); print(pta.data())
    pta.set_args('settings --pta_mode 4w'); print(pta.data())
    pta.set_args('settings --request_signal_active_level low'); print(pta.data())
    pta.set_args('settings --priority_signal_active_level low'); print(pta.data())
    pta.set_args('settings --freq_signal_active_level low'); print(pta.data())
    pta.set_args('settings --grant_signal_active_level high'); print(pta.data())
    pta.set_args('settings --coex_type generic'); print(pta.data())
    pta.set_args('settings --coex_type ble'); print(pta.data())
    pta.set_args('settings --default_grant_state no_grant'); print(pta.data())
    pta.set_args('settings --simultaneous_rx_accesses true'); print(pta.data())
    pta.set_args('settings --priority_sampling_time 3'); print(pta.data())
    pta.set_args('settings --tx_rx_sampling_time 4'); print(pta.data())
    pta.set_args('settings --freq_sampling_time 5'); print(pta.data())
    pta.set_args('settings --grant_valid_time 6'); print(pta.data())
    pta.set_args('settings --fem_control_time 7'); print(pta.data())
    pta.set_args('settings --first_slot_time 8'); print(pta.data())
    pta.set_args('settings --periodic_tx_rx_sampling_time 9'); print(pta.data())
    pta.set_args('settings --coex_quota 1000'); print(pta.data())
    pta.set_args('settings --wlan_quota 1234'); print(pta.data())
    pta.set_args('state --state off'); print(pta.data())
    pta.set_args('state --state on'); print(pta.data())
    pta.set_args('priority --priority_mode balanced'); print(pta.data())
    return 0


if __name__ == '__main__':
    if len(sys.argv) > 1:
        sys.exit(command_line_main())
    else:
        sys.exit(command_line_test())
